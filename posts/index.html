<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Restart | 重开</title><meta name=keywords content><meta name=description content="Posts - Restart | 重开"><meta name=author content><link rel=canonical href=https://weita0.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://weita0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weita0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weita0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://weita0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://weita0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://weita0.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://weita0.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://weita0.github.io/posts/"><meta property="og:site_name" content="Restart | 重开"><meta property="og:title" content="Posts"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weita0.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weita0.github.io/ accesskey=h title="Restart | 重开 (Alt + H)">Restart | 重开</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Keep looking, don't Settle</h2></header><div class=entry-content><p>标题这句话出自 Jobs 在斯坦福毕业典礼上的演讲，我觉得在此用作这个时隔多年重启的博客的第一篇文章的标题非常合适。
多年以前，在某处看过这个演讲，但那时感触并不深。现在把演讲视频在B站上找出来重看了一遍，才发现 Jobs 对于我的影响是多么巨大。
我想在此挑出演讲中的一些段落，放在这篇文章里，在这个无人问津的角落，用以自勉，并时刻提醒自己，不忘初心。
Jobs 在演讲里讲述了三个发生在他身上的故事，每个故事都围绕一个主题。
1st Story: connect the dots I had no idea what I wanted to do with my life, and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at that time. But looking back, it was one of the best decisions I ever made. The minute I dropped out, I could stop taking the required classes that didn’t interest me and begin dropping in on the ones that looked far more interesting.
...</p></div><footer class=entry-footer><span title='2025-04-28 15:47:10 +0800 CST'>April 28, 2025</span></footer><a class=entry-link aria-label="post link to Keep looking, don't Settle" href=https://weita0.github.io/posts/restart/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>写作计划</h2></header><div class=entry-content><p>技术 主题 进度 Promise 50% animation - rsc - random algo - 随笔 主题 进度 泡泡玛特 - 塔勒布 - 翻译 主题 进度 - -</p></div><footer class=entry-footer><span title='2025-06-15 00:00:00 +0000 UTC'>June 15, 2025</span></footer><a class=entry-link aria-label="post link to 写作计划" href=https://weita0.github.io/posts/%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>20 Albums（下）</h2></header><div class=entry-content><p>这是我的选择（排名不分先后）。因为选择太有限、太宝贵了，所以我只会从每个音乐人/乐队的作品里选择其一。
11. Bon Iver - Bon Iver 认识Bon Iver以及这个名字背后的音乐人Justin Vernon，始于&lt;不在场>这个播客第一季的最后两期节目，那两期节目我反复听了很多遍，如同Bon Iver的音乐一样，都有一种力量，给心中带来慰藉。
12. 万能青年旅店 - 冀西南林路行 13. （End）</p></div><footer class=entry-footer><span title='2025-06-16 00:00:00 +0000 UTC'>June 16, 2025</span></footer><a class=entry-link aria-label="post link to 20 Albums（下）" href=https://weita0.github.io/posts/20-albums-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Promise（下）</h2></header><div class=entry-content><p>书接上回，我们实现了一个基本的Promise，这回让我们来探究Promise.all、Promise.race和Promise.allSettled的实现。
Promise.all 首先明确一下目标：
接收一个数组（或可迭代对象），元素可以是值或 Promise 所有 Promise 都成功，返回一个按原始顺序组成的结果数组 只要有一个失败（reject），整个返回的 Promise 立即 reject 返回的数组顺序必须与传入顺序一致。 如果传入的数组为空，立即resolve（这一点和Promise.race有所区别，如果Promise.race传入空数组，会一直挂起） 实现：
1class MyPromise { 2 // 基础实现请参考上篇 3 static all(iterable) { 4 // 构造一个Promise 5 let p = new MyPromise(function () {}); 6 7 let res = []; // 用于存放resolved value 8 let ret = iterable.length; 9 iterable.forEach((item, i) => { 10 MyPromise.resolve(item) 11 .then((value) => { 12 res[i] = value; 13 if (!--ret) { 14 p.settlePromise($resolved, res); 15 } 16 }) 17 .catch((reason) => { 18 // 任何一个promise reject都直接reject这个Promise.all 19 p.settlePromise($rejected, reason); 20 }); 21 }); 22 if (!ret) { 23 p.settlePromise($resolved, []); 24 } 25 return p; 26 } 27} Promise.race 目标：
...</p></div><footer class=entry-footer><span title='2025-06-16 00:00:00 +0000 UTC'>June 16, 2025</span></footer><a class=entry-link aria-label="post link to Promise（下）" href=https://weita0.github.io/posts/promise-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Promise（上）</h2></header><div class=entry-content><p>引子 作为JavaScript开发者，Promise可以说是我们的工具库中最最基础的工具之一了，如果你不仅仅满足于能够熟练使用这个趁手的工具，那么这篇文章就是为你准备的。
规范 首先，让我们来看一下Promises/A+ —— 一个专门制订Promise规范的组织 —— 给出的Promise规范。规范之所以重要，是因为我们的实现要严格根据规范来。如果你认为自己已经足够了解Promise API了，或者觉得上来就看规范过于枯燥，那么也可以先跳过这部分，结合具体的实现来看，也是可以的。
1. 相关术语 promise is an object or function with a then method whose behavior conforms to this specification.
promise是拥有符合规范的then方法的对象或函数。 thenable is an object or function that defines a then method.
thenable指定义了then方法的对象或函数。 value is any legal JavaScript value(including undefined, a thenable, or a promise).
value可以是任何合法的JavaScript值，包括undefined。 exception is a value that is thrown using the throw statement.
exception是通过throw语句抛出的一个值。 reason is a value that indicates why a promise was rejected.
reason表示promise失败的原因。 2. 要求 2.1 状态 一个Promise只能是pending、fulfilled、rejected三种状态（其一）。
...</p></div><footer class=entry-footer><span title='2025-06-13 00:00:00 +0000 UTC'>June 13, 2025</span></footer><a class=entry-link aria-label="post link to Promise（上）" href=https://weita0.github.io/posts/promise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>When to Do What You Love</h2></header><div class=entry-content><p>这是一篇译文，原文作者是Paul Graham。 大一的时候就拜读过阮一峰老师翻译的Paul Graham文集&lt;黑客与画家>，并深受影响。
There’s some debate about whether it’s a good idea to “follow your passion”. In fact the question is impossible to answer with a simple yes or no. Sometimes you should and sometimes you shouldn’t, but the border between should and shouldn’t is very complicated. The only way to give a general answer is to trace it.
「从事你真正热爱的事业」是否是个好主意，长久以来都争论不断。事实上，这个问题很难用一个简单的「是」或「否」来回答。有时候你应该而有时候你不应该，而要搞清这两者的边界非常复杂。
（“follow your passion"直译为「追随你的热情」，在英文语境下经常用于激励人们找到自己真正热爱的事情，并将其作为事业或生活的方向。这种表达在汉语文化里比较罕见，很少有父母或老师会对自己的孩子和学生说「追随你的热情吧」，他们会说，好好读书，将来才能出人头地。 所谓「出人头地」，就是大多数中国父母心中替子女定义的成功标准。至于你内心是否充盈是否快乐，不会有人在意（甚至也会被自己内心刻意忽略）。这里我没有用「追随你的热情」这种在中文语境里略显抽象的表达，而是「从事你真正热爱的事业」这种稍微具象一点的表达。）
When people talk about this question, there’s always an implicit “instead of”. All other things being equal, why shouldn’t you work on what interests you the most? So even raising the question implies that all other things aren’t equal, and that you have to choose between working on what interests you the most and something else, like what pays the best.
...</p></div><footer class=entry-footer><span title='2025-06-08 00:00:00 +0000 UTC'>June 8, 2025</span></footer><a class=entry-link aria-label="post link to When to Do What You Love" href=https://weita0.github.io/posts/when-to-do-what-you-love/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Side Effect</h2></header><div class=entry-content><p>什么是副作用？ 副作用（side effect）指的是调用函数时，除了返回值外，对主调用函数产生的附加影响。
比如修改函数外的变量，事件订阅，数据获取，修改DOM。
在React中，可以使用useEffect和useLayoutEffect和useInsertionEffect三种hook来声明组件的副作用。
三种hook的具体区别可以参考React官方文档，这里不再赘述。
在React Fiber架构下，effect分为收集（render）和执行（commit）两个阶段。在收集阶段，收集信息，构建链表。在执行阶段，执行实际的副作用函数和清理函数。
render阶段 在render阶段，React会为每个副作用单独创建一个hook对象，并以链表（linked list）的形式保存在Fiber节点的memoizedState字段上。
1export type Fiber = { 2 memoizedState: any, 3 // A queue of state updates and callbacks 4 updateQueue: mixed, 5 // ... 6} 结合源码来看下useEffect的具体实现。
1// react-reconciler/src/ReactFiberHooks 2 3// 当前fiber的hook链表 4let currentHook: Hook | null = null; 5// 更新中的hook链表 6let workInProgressHook: Hook | null = null; 7 8// `mountEffect` 即 `useEffect` 9function mountEffect( 10 create: () => (() => void) | void, 11 deps: Array&lt;mixed> | void | null, 12): void { 13 mountEffectImpl( 14 PassiveEffect | PassiveStaticEffect, // fiber上的标记，待会会加到fiber.flags上 15 HookPassive, // effect上的tag，表示这个hook的类型 16 create, // useEffect里定义的函数 17 deps, // useEffect依赖项 18 ) 19} 20 21function mountEffectImpl( 22 fiberFlags: Flags, 23 hookFlags: HookFlags, 24 create: () => (() => void) | void, 25 deps: Array&lt;mixed> | void | null, 26): void { 27 // 构造一个新的hook容器，并把上一个hook的next指向它(如果为空，就把它当作起始的hook，并保存在fiber的memoizedState上，具体的实现在后面)。 28 const hook = mountWorkInProgressHook(); 29 const nextDeps = deps === undefined ? null : deps; 30 // 给fiber节点打上effect标记 31 currentlyRenderingFiber.flags |= fiberFlags; 32 // 调用pushSimpleEffect将effect信息保存在当前hook的`memoizedState`上。 33 // 注意hook的memoizedState不仅用于保存useEffect，useState、useRef等其他hook也存在这条链上。 34 // 具体的实现请往后看。 35 hook.memoizedState = pushSimpleEffect( 36 HookHasEffect | hookFlags, 37 createEffectInstance(), 38 create, 39 nextDeps, 40 ); 41} 42// 创建effect实例：一个包含destroy属性的对象 43function createEffectInstance(): EffectInstance { 44 return {destroy: undefined}; 45} 46 47function pushSimpleEffect( 48 tag: HookFlags, 49 inst: EffectInstance, 50 create: () => (() => void) | void, 51 deps: Array&lt;mixed> | void | null, 52): Effect { 53 // 初始化一个effect容器，用于保存create、deps和实例信息。 54 const effect: Effect = { 55 tag, 56 create, 57 deps, 58 inst, 59 // Circular 60 next: (null: any), 61 }; 62 return pushEffectImpl(effect); 63} 64 65function pushEffectImpl(effect: Effect): Effect { 66 // `updateQueue`专门用于存储当前fiber节点的副作用，也是链式结构 67 // `updateQueue`包含一个`lastEffect`属性，指向当前fiber节点的最后一个effect对象 68 let componentUpdateQueue: null | FunctionComponentUpdateQueue = 69 (currentlyRenderingFiber.updateQueue: any); 70 // 如果为空，创建一个空的`updateQueue`对象，并挂载到fiber上。 71 if (componentUpdateQueue === null) { 72 componentUpdateQueue = createFunctionComponentUpdateQueue(); 73 currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); 74 } 75 const lastEffect = componentUpdateQueue.lastEffect; 76 if (lastEffect === null) { 77 // 如果lastEffect指向为空，就指向传入的effect，并把该effect的next指向自身（为了成环） 78 componentUpdateQueue.lastEffect = effect.next = effect; 79 } else { 80 // 如果不为空，把updateQueue.lastEffect指向传入的effect，并把该effect的next指向链表的第一个effect 81 // 也就是lastEffect.next 原先指向的effect。 82 const firstEffect = lastEffect.next; 83 lastEffect.next = effect; 84 effect.next = firstEffect; 85 componentUpdateQueue.lastEffect = effect; 86 } 87 return effect; 88} pushEffectImpl的逻辑看起来有些绕，简单来说，节点上的effect是个环形链，updateQueue永远指向最后一个effect，这个effect又有一个next属性指向第一个effect。每次插入新的effect，都会插在最后，也就是updateQueue.lastEffect。
...</p></div><footer class=entry-footer><span title='2025-06-04 00:00:00 +0000 UTC'>June 4, 2025</span></footer><a class=entry-link aria-label="post link to Side Effect" href=https://weita0.github.io/posts/side-effect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Manufacture DOM</h2></header><div class=entry-content><p>引子 在我上学那会，还没有前端相关的课程（最接近前端的课程是用前端三剑客——Dreamweaver做HTML网页），学的编程语言是Java或C#。大四去公司实习，一开始也是写Java，后来一个机缘巧合，当时我的mentor让我选是继续做Java还是做前端，当时觉得前端所见即所得，很好玩，于是便开启了我的前端生涯。
带我入门前端领域的第一本书是「JavaScript DOM编程艺术」，当时的前端还方兴未艾，React和Vue还不为大多数人所知，jQuery是当时的主流框架，日常开发就是使用$去查找DOM元素并直接在DOM上进行操作，没经历过那个时代很难想象。
现如今，由于React及虚拟DOM的普及，实际开发中已经很少需要用到查找和直接操作DOM的方法了，这导致我们渐渐遗忘了这些API。本文（可能是一个系列）的初衷就是帮助自己和读者（假如有）搞懂React是如何替我们创建和维护DOM并把背后的复杂性给巧妙隐藏起来的。
正文 React更新大致分为三个阶段：
Reconciliation 构建新的Fiber Tree，并标记每个节点的变化类型 Commit 根据标记更新实际的DOM，并执行副作用，包括DOM操作、ref、useEffect等 Passive Effects 异步执行useEffect中注册的副作用 在第一阶段，每个Fiber节点会被打上变化标记（存储在flags这个字段上）。 标记类型分为三种；Placement、Update、Deletion，对应新增、更新和删除。
在第二阶段，React会从根节点开始，深度优先遍历Fiber Tree，检查每个节点的标记（flags），然后执行相应的操作。
标记类型 操作 Placement insertDOMNode Update updateDOMNode Deletion removeChild 让我们来看一下新增节点的具体实现，这段源码在react/packages/react-reconciler/src/ReactFiberCommitHostEffects.js这个文件中，这里为了便于理解对源码做了一些精简。
1function commitPlacement(finishedWork: Fiber): void { 2 let hostParentFiber; 3 let parentFiber = finishedWork.return; 4 while (parentFiber !== null) { 5 if (isHostParent(parentFiber)) { 6 hostParentFiber = parentFiber; 7 break; 8 } 9 parentFiber = parentFiber.return; 10 } 11 12 if (hostParentFiber == null) { 13 throw new Error( 14 'Expected to find a host parent. This error is likely caused by a bug ' + 15 'in React. Please file an issue.', 16 ); 17 } 18 19 switch (hostParentFiber.tag) { 20 case HostComponent: { 21 const parent: Instance = hostParentFiber.stateNode; 22 const before = getHostSibling(finishedWork); 23 // We only have the top Fiber that was inserted but we need to recurse down its 24 // children to find all the terminal nodes. 25 insertOrAppendPlacementNode( 26 finishedWork, 27 before, 28 parent, 29 parentFragmentInstances, 30 ); 31 break; 32 } 33 case HostRoot: 34 case HostPortal: { 35 const parent: Container = hostParentFiber.stateNode.containerInfo; 36 const before = getHostSibling(finishedWork); 37 insertOrAppendPlacementNodeIntoContainer( 38 finishedWork, 39 before, 40 parent, 41 parentFragmentInstances, 42 ); 43 break; 44 } 45 default: 46 throw new Error( 47 'Invalid host parent fiber. This error is likely caused by a bug ' + 48 'in React. Please file an issue.', 49 ); 50 } 51} fiber.return指向当前fiber的父节点。
...</p></div><footer class=entry-footer><span title='2025-06-02 18:29:09 +0800 CST'>June 2, 2025</span></footer><a class=entry-link aria-label="post link to Manufacture DOM" href=https://weita0.github.io/posts/react-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FPS</h2></header><div class=entry-content><p>如何通过JavaScript获知当前页面的实时帧数，虽然没有类似getFPS这样的方法可以直接调用，但我们可以自己实现一个。
1import { useEffect, useState } from "react"; 2 3function FPSIndex() { 4 const [fps, setFps] = useState(0); 5 6 useEffect(() => { 7 let lastTime = performance.now(); 8 let frame = 0; 9 let fps = 0; 10 11 function loop(now) { 12 frame++; 13 14 const delta = now - lastTime; 15 if (delta >= 1000) { 16 fps = frame / (delta / 1000); 17 setFps(fps); 18 frame = 0; 19 lastTime = now; 20 } 21 22 requestAnimationFrame(loop); 23 } 24 25 requestAnimationFrame(loop); 26 }, []); 27 28 return &lt;h1>{`FPS: ${fps.toFixed(0)}`}&lt;/h1>; 29} ...</p></div><footer class=entry-footer><span title='2025-05-26 23:15:58 +0800 CST'>May 26, 2025</span></footer><a class=entry-link aria-label="post link to FPS" href=https://weita0.github.io/posts/fps/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pull to Refresh</h2></header><div class=entry-content><p>下拉刷新大概是我们日常使用手机时最常做的一个操作，为了消解无聊，在各个App间频繁切换（无一例外这些App都采用了瀑布流），上滑、下滑，试图用信息把头脑填满。
那么如何实现这个看似简单的功能呢。
正式开始前，我们需要做一点准备工作。
首先，我们得有一个瀑布流。
1function Waterfall() { 2 const [l1, setL1] = useState([]); 3 const [l2, setL2] = useState([]); 4 const startQuery = async () => { 5 const [l1, l2] = await Promise.all([ 6 fetch('http://localhost:3000/list').then(res => res.json()), 7 fetch('http://localhost:3000/list').then(res => res.json()), 8 ]) 9 setL1(l1); 10 setL2(l2); 11 } 12 13 useEffect(() => { 14 startQuery(); 15 }, []); 16 return ( 17 &lt;div className="h-screen w-full grid grid-cols-2"> 18 &lt;div className="w-full flex flex-col justify-start items-center"> 19 {l1.map(color => &lt;Card color={color} />)} 20 &lt;/div> 21 &lt;div className="w-full flex flex-col justify-start items-center"> 22 {l2.map(color => &lt;Card color={color} />)} 23 &lt;/div> 24 &lt;/div> 25 ) 26} 这里我用nest在本地启了一个node服务，接口会返回一串随机的颜色，像['#ffffff', '#000000', ...]这样，并有一个额外的delay用来模拟网络延迟。
...</p></div><footer class=entry-footer><span title='2025-05-12 11:20:13 +0800 CST'>May 12, 2025</span></footer><a class=entry-link aria-label="post link to Pull to Refresh" href=https://weita0.github.io/posts/pull-to-refresh/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://weita0.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://weita0.github.io/>Restart | 重开</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>