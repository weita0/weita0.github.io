<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Restart | 重开</title><meta name=keywords content><meta name=description content="Posts - Restart | 重开"><meta name=author content><link rel=canonical href=https://weita0.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://weita0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weita0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weita0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://weita0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://weita0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://weita0.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://weita0.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://weita0.github.io/posts/"><meta property="og:site_name" content="Restart | 重开"><meta property="og:title" content="Posts"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weita0.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weita0.github.io/ accesskey=h title="Restart | 重开 (Alt + H)">Restart | 重开</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>When to Do What You Love</h2></header><div class=entry-content><p>这是一篇译文，原文作者是Paul Graham。 大一的时候就拜读过阮一峰老师翻译的Paul Graham文集&lt;黑客与画家>，并深受影响。
There’s some debate about whether it’s a good idea to “follow your passion”. In fact the question is impossible to answer with a simple yes or no. Sometimes you should and sometimes you shouldn’t, but the border between should and shouldn’t is very complicated. The only way to give a general answer is to trace it.
「做你真正喜欢的事」是否是个好主意，长久以来都争论不断。事实上，这个问题很难用一个简单的「是」或「否」来回答。有时候你应该而有时候你不应该，而要搞清这两者的边界非常复杂。
（“follow your passion"直译为「追随你的热情」，在英语文化里经常用于激励人们找到自己真正热爱的事情，并将其作为事业或生活的方向。这种表达在汉语文化里比较罕见，很少有父母或老师对自己的孩子和学生说「追随你的热情吧」，他们会说，好好读书，将来才有出息。 所谓「有出息」，就是取得世俗意义上的成功，过上人人艳羡的生活。至于你内心是否充盈是否快乐，不会有人很在意（甚至自己内心也会刻意忽略）。这里我没有用「追随你的热情」这种在中文里略显抽象的表达，而用了「做你真正喜欢的事」这种稍微具象一点的表达。）
When people talk about this question, there’s always an implicit “instead of”. All other things being equal, why shouldn’t you work on what interests you the most? So even raising the question implies that all other things aren’t equal, and that you have to choose between working on what interests you the most and something else, like what pays the best.
...</p></div><footer class=entry-footer><span title='2025-06-08 00:00:00 +0000 UTC'>June 8, 2025</span></footer><a class=entry-link aria-label="post link to When to Do What You Love" href=https://weita0.github.io/posts/when-to-do-what-you-love/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>副作用</h2></header><div class=entry-content><p>什么是副作用？ 副作用（side effect）指的是调用函数时，除了返回值外，对主调用函数产生的附加影响。
比如修改函数外的变量，事件订阅，数据获取，修改DOM。
在React中，可以使用useEffect和useLayoutEffect和useInsertionEffect三种hook来声明组件的副作用。
三种hook的具体区别可以参考React官方文档，这里不再赘述。
在React Fiber架构下，effect分为收集（render）和执行（commit）两个阶段。在收集阶段，收集信息，构建链表。在执行阶段，执行实际的副作用函数和清理函数。
render阶段 在render阶段，React会为每个副作用单独创建一个hook对象，并以链表（linked list）的形式保存在Fiber节点的memoizedState字段上。
1export type Fiber = { 2 memoizedState: any, 3 // A queue of state updates and callbacks 4 updateQueue: mixed, 5 // ... 6} 结合源码来看下useEffect的具体实现。
1// react-reconciler/src/ReactFiberHooks 2 3// 当前fiber的hook链表 4let currentHook: Hook | null = null; 5// 更新中的hook链表 6let workInProgressHook: Hook | null = null; 7 8// `mountEffect` 即 `useEffect` 9function mountEffect( 10 create: () => (() => void) | void, 11 deps: Array&lt;mixed> | void | null, 12): void { 13 mountEffectImpl( 14 PassiveEffect | PassiveStaticEffect, // fiber上的标记，待会会加到fiber.flags上 15 HookPassive, // effect上的tag，表示这个hook的类型 16 create, // useEffect里定义的函数 17 deps, // useEffect依赖项 18 ) 19} 20 21function mountEffectImpl( 22 fiberFlags: Flags, 23 hookFlags: HookFlags, 24 create: () => (() => void) | void, 25 deps: Array&lt;mixed> | void | null, 26): void { 27 // 构造一个新的hook容器，并把上一个hook的next指向它(如果为空，就把它当作起始的hook，并保存在fiber的memoizedState上，具体的实现在后面)。 28 const hook = mountWorkInProgressHook(); 29 const nextDeps = deps === undefined ? null : deps; 30 // 给fiber节点打上effect标记 31 currentlyRenderingFiber.flags |= fiberFlags; 32 // 调用pushSimpleEffect将effect信息保存在当前hook的`memoizedState`上。 33 // 注意hook的memoizedState不仅用于保存useEffect，useState、useRef等其他hook也存在这条链上。 34 // 具体的实现请往后看。 35 hook.memoizedState = pushSimpleEffect( 36 HookHasEffect | hookFlags, 37 createEffectInstance(), 38 create, 39 nextDeps, 40 ); 41} 42// 创建effect实例：一个包含destroy属性的对象 43function createEffectInstance(): EffectInstance { 44 return {destroy: undefined}; 45} 46 47function pushSimpleEffect( 48 tag: HookFlags, 49 inst: EffectInstance, 50 create: () => (() => void) | void, 51 deps: Array&lt;mixed> | void | null, 52): Effect { 53 // 初始化一个effect容器，用于保存create、deps和实例信息。 54 const effect: Effect = { 55 tag, 56 create, 57 deps, 58 inst, 59 // Circular 60 next: (null: any), 61 }; 62 return pushEffectImpl(effect); 63} 64 65function pushEffectImpl(effect: Effect): Effect { 66 // `updateQueue`专门用于存储当前fiber节点的副作用，也是链式结构 67 // `updateQueue`包含一个`lastEffect`属性，指向当前fiber节点的最后一个effect对象 68 let componentUpdateQueue: null | FunctionComponentUpdateQueue = 69 (currentlyRenderingFiber.updateQueue: any); 70 // 如果为空，创建一个空的`updateQueue`对象，并挂载到fiber上。 71 if (componentUpdateQueue === null) { 72 componentUpdateQueue = createFunctionComponentUpdateQueue(); 73 currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); 74 } 75 const lastEffect = componentUpdateQueue.lastEffect; 76 if (lastEffect === null) { 77 // 如果lastEffect指向为空，就指向传入的effect，并把该effect的next指向自身（为了成环） 78 componentUpdateQueue.lastEffect = effect.next = effect; 79 } else { 80 // 如果不为空，把updateQueue.lastEffect指向传入的effect，并把该effect的next指向链表的第一个effect 81 // 也就是lastEffect.next 原先指向的effect。 82 const firstEffect = lastEffect.next; 83 lastEffect.next = effect; 84 effect.next = firstEffect; 85 componentUpdateQueue.lastEffect = effect; 86 } 87 return effect; 88} pushEffectImpl的逻辑看起来有些绕，简单来说，节点上的effect是个环形链，updateQueue永远指向最后一个effect，这个effect又有一个next属性指向第一个effect。每次插入新的effect，都会插在最后，也就是updateQueue.lastEffect。
...</p></div><footer class=entry-footer><span title='2025-06-04 10:00:30 +0800 CST'>June 4, 2025</span></footer><a class=entry-link aria-label="post link to 副作用" href=https://weita0.github.io/posts/%E5%89%AF%E4%BD%9C%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>制造DOM</h2></header><div class=entry-content><p>引子 在我上学那会，还没有前端相关的课程（最接近前端的课程是用前端三剑客——Dreamweaver做HTML网页），学的编程语言是Java或C#。大四去公司实习，一开始也是写Java，后来一个机缘巧合，当时我的mentor让我选是继续做Java还是做前端，当时觉得前端所见即所得，很好玩，于是便开启了我的前端生涯。
带我入门前端领域的第一本书是「JavaScript DOM编程艺术」，当时的前端还方兴未艾，React和Vue还不为大多数人所知，jQuery是当时的主流框架，日常开发就是使用$去查找DOM元素并直接在DOM上进行操作，没经历过那个时代很难想象。
现如今，由于React及虚拟DOM的普及，实际开发中已经很少需要用到查找和直接操作DOM的方法了，这导致我们渐渐遗忘了这些API。本文（可能是一个系列）的初衷就是帮助自己和读者（假如有）搞懂React是如何替我们创建和维护DOM并把背后的复杂性给巧妙隐藏起来的。
正文 React更新大致分为三个阶段：
Reconciliation 构建新的Fiber Tree，并标记每个节点的变化类型 Commit 根据标记更新实际的DOM，并执行副作用，包括DOM操作、ref、useEffect等 Passive Effects 异步执行useEffect中注册的副作用 在第一阶段，每个Fiber节点会被打上变化标记（存储在flags这个字段上）。 标记类型分为三种；Placement、Update、Deletion，对应新增、更新和删除。
在第二阶段，React会从根节点开始，深度优先遍历Fiber Tree，检查每个节点的标记（flags），然后执行相应的操作。
标记类型 操作 Placement insertDOMNode Update updateDOMNode Deletion removeChild 让我们来看一下新增节点的具体实现，这段源码在react/packages/react-reconciler/src/ReactFiberCommitHostEffects.js这个文件中，这里为了便于理解对源码做了一些精简。
1function commitPlacement(finishedWork: Fiber): void { 2 let hostParentFiber; 3 let parentFiber = finishedWork.return; 4 while (parentFiber !== null) { 5 if (isHostParent(parentFiber)) { 6 hostParentFiber = parentFiber; 7 break; 8 } 9 parentFiber = parentFiber.return; 10 } 11 12 if (hostParentFiber == null) { 13 throw new Error( 14 'Expected to find a host parent. This error is likely caused by a bug ' + 15 'in React. Please file an issue.', 16 ); 17 } 18 19 switch (hostParentFiber.tag) { 20 case HostComponent: { 21 const parent: Instance = hostParentFiber.stateNode; 22 const before = getHostSibling(finishedWork); 23 // We only have the top Fiber that was inserted but we need to recurse down its 24 // children to find all the terminal nodes. 25 insertOrAppendPlacementNode( 26 finishedWork, 27 before, 28 parent, 29 parentFragmentInstances, 30 ); 31 break; 32 } 33 case HostRoot: 34 case HostPortal: { 35 const parent: Container = hostParentFiber.stateNode.containerInfo; 36 const before = getHostSibling(finishedWork); 37 insertOrAppendPlacementNodeIntoContainer( 38 finishedWork, 39 before, 40 parent, 41 parentFragmentInstances, 42 ); 43 break; 44 } 45 default: 46 throw new Error( 47 'Invalid host parent fiber. This error is likely caused by a bug ' + 48 'in React. Please file an issue.', 49 ); 50 } 51} fiber.return指向当前fiber的父节点。
...</p></div><footer class=entry-footer><span title='2025-06-02 18:29:09 +0800 CST'>June 2, 2025</span></footer><a class=entry-link aria-label="post link to 制造DOM" href=https://weita0.github.io/posts/react-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FPS</h2></header><div class=entry-content><p>如何通过JavaScript获知当前页面的实时帧数，虽然没有类似getFPS这样的方法可以直接调用，但我们可以自己实现一个。
1import { useEffect, useState } from "react"; 2 3function FPSIndex() { 4 const [fps, setFps] = useState(0); 5 6 useEffect(() => { 7 let lastTime = performance.now(); 8 let frame = 0; 9 let fps = 0; 10 11 function loop(now) { 12 frame++; 13 14 const delta = now - lastTime; 15 if (delta >= 1000) { 16 fps = frame / (delta / 1000); 17 setFps(fps); 18 frame = 0; 19 lastTime = now; 20 } 21 22 requestAnimationFrame(loop); 23 } 24 25 requestAnimationFrame(loop); 26 }, []); 27 28 return &lt;h1>{`FPS: ${fps.toFixed(0)}`}&lt;/h1>; 29} ...</p></div><footer class=entry-footer><span title='2025-05-26 23:15:58 +0800 CST'>May 26, 2025</span></footer><a class=entry-link aria-label="post link to FPS" href=https://weita0.github.io/posts/fps/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pull to Refresh | 下拉刷新</h2></header><div class=entry-content><p>下拉刷新大概是我们日常使用手机时最常做的一个操作，为了消解无聊，在各个App间频繁切换（无一例外这些App都采用了瀑布流），上滑、下滑，试图用信息把头脑填满。
那么如何实现这个看似简单的功能呢。
正式开始前，我们需要做一点准备工作。
首先，我们得有一个瀑布流。
1function Waterfall() { 2 const [l1, setL1] = useState([]); 3 const [l2, setL2] = useState([]); 4 const startQuery = async () => { 5 const [l1, l2] = await Promise.all([ 6 fetch('http://localhost:3000/list').then(res => res.json()), 7 fetch('http://localhost:3000/list').then(res => res.json()), 8 ]) 9 setL1(l1); 10 setL2(l2); 11 } 12 13 useEffect(() => { 14 startQuery(); 15 }, []); 16 return ( 17 &lt;div className="h-screen w-full grid grid-cols-2"> 18 &lt;div className="w-full flex flex-col justify-start items-center"> 19 {l1.map(color => &lt;Card color={color} />)} 20 &lt;/div> 21 &lt;div className="w-full flex flex-col justify-start items-center"> 22 {l2.map(color => &lt;Card color={color} />)} 23 &lt;/div> 24 &lt;/div> 25 ) 26} 这里我用nest在本地启了一个node服务，接口会返回一串随机的颜色，像['#ffffff', '#000000', ...]这样，并有一个额外的delay用来模拟网络延迟。
...</p></div><footer class=entry-footer><span title='2025-05-12 11:20:13 +0800 CST'>May 12, 2025</span></footer><a class=entry-link aria-label="post link to Pull to Refresh | 下拉刷新" href=https://weita0.github.io/posts/pull-to-refresh/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Before You Memo()</h2></header><div class=entry-content><p>这是一篇译文，原文是Dan Abramov博客上的同名文章，没有任何商业目的，仅本身兴趣所致。 网上有许多介绍React性能优化的文章，通常来说，如果某些状态更新很慢，你需要：
确保你运行的是生产环境下构建出的产物（开发环境下本身就会更慢，极端情况下甚至会慢一个数级） 确保你没有把组件状态提升到不必要的层级（比如，把input框的状态保存在一个中心化的Store中） 用React开发工具Profiler查看哪些组件在重绘，并用memo()包装那些开销最大的子树（并在需要时加上useMemo()） 最后一步很烦人，尤其是那些位于中间层的组件。理想情况下，编译器能替你完成这些工作。未来也许会实现的。
在这篇文章中，我想分享两种不同的技巧。他们过于基础，乃至于人们很少意识到他们实实在在地提升了渲染性能。
这两种技巧可以作为你已经知道的那些技巧的补充。他们不会替代memo 和useMemo，但通常都是可以优先考虑的、不错的尝试。
一个人为的慢组件 这是一个有严重性能问题的组件：
1import { useState } from 'react'; 2 3export default function App() { 4 let [color, setColor] = useState('red'); 5 return ( 6 &lt;div> 7 &lt;input value={color} onChange={(e) => setColor(e.target.value)} /> 8 &lt;p style={{ color }}>Hello, world!&lt;/p> 9 &lt;ExpensiveTree /> 10 &lt;/div> 11 ) 12} 13 14function ExpensiveTree() { 15 let now = performance.now(); 16 while (performance.now() - now &lt; 100) { 17 // Artificial delay -- do nothing for 100ms 18 } 19 return &lt;p>I am a very slow component tree.&lt;/p> 20} 问题在于不管color什么时候改变，我们都会重绘&lt;ExpensiveTree />，这个组件内部会被人为地延迟，所以很慢。
...</p></div><footer class=entry-footer><span title='2025-05-05 16:00:42 +0800 CST'>May 5, 2025</span></footer><a class=entry-link aria-label="post link to Before You Memo()" href=https://weita0.github.io/posts/before-you-memo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Keep looking, don't Settle</h2></header><div class=entry-content><p>标题这句话出自 Jobs 在斯坦福毕业典礼上的演讲，我觉得在此用作这个时隔多年重启的博客的第一篇文章的标题非常合适。
多年以前，在某处看过这个演讲，但那时感触并不深。现在把演讲视频在B站上找出来重看了一遍，才发现 Jobs 对于我的影响是多么巨大。
我想在此挑出演讲中的一些段落，放在这篇文章里，在这个无人问津的角落，用以自勉，并时刻提醒自己，不忘初心。
Jobs 在演讲里讲述了三个发生在他身上的故事，每个故事都围绕一个主题。
1st Story: connect the dots I had no idea what I wanted to do with my life, and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at that time. But looking back, it was one of the best decisions I ever made. The minute I dropped out, I could stop taking the required classes that didn’t interest me and begin dropping in on the ones that looked far more interesting.
...</p></div><footer class=entry-footer><span title='2025-04-28 15:47:10 +0800 CST'>April 28, 2025</span></footer><a class=entry-link aria-label="post link to Keep looking, don't Settle" href=https://weita0.github.io/posts/restart/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://weita0.github.io/>Restart | 重开</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>